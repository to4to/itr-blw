// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: employee.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employee (
    employee_id, created_at, updated_at, name,
    joining_date, salary, pan_number, year,
    tax_income, deductions, designation
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING employee_id, created_at, updated_at, name, joining_date, salary, pan_number, year, tax_income, deductions, designation
`

type CreateEmployeeParams struct {
	EmployeeID  uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Name        string
	JoiningDate time.Time
	Salary      string
	PanNumber   string
	Year        int32
	TaxIncome   string
	Deductions  sql.NullString
	Designation string
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, createEmployee,
		arg.EmployeeID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.JoiningDate,
		arg.Salary,
		arg.PanNumber,
		arg.Year,
		arg.TaxIncome,
		arg.Deductions,
		arg.Designation,
	)
	var i Employee
	err := row.Scan(
		&i.EmployeeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.JoiningDate,
		&i.Salary,
		&i.PanNumber,
		&i.Year,
		&i.TaxIncome,
		&i.Deductions,
		&i.Designation,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :exec
DELETE FROM employee
WHERE employee_id = $1
`

func (q *Queries) DeleteEmployee(ctx context.Context, employeeID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEmployee, employeeID)
	return err
}

const findAllEmployee = `-- name: FindAllEmployee :many
SELECT employee_id, created_at, updated_at, name, joining_date, salary, pan_number, year, tax_income, deductions, designation
FROM employee
`

func (q *Queries) FindAllEmployee(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, findAllEmployee)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.JoiningDate,
			&i.Salary,
			&i.PanNumber,
			&i.Year,
			&i.TaxIncome,
			&i.Deductions,
			&i.Designation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findEmployee = `-- name: FindEmployee :one
SELECT employee_id, created_at, updated_at, name, joining_date, salary, pan_number, year, tax_income, deductions, designation
FROM employee
WHERE employee_id = $1
`

func (q *Queries) FindEmployee(ctx context.Context, employeeID uuid.UUID) (Employee, error) {
	row := q.db.QueryRowContext(ctx, findEmployee, employeeID)
	var i Employee
	err := row.Scan(
		&i.EmployeeID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.JoiningDate,
		&i.Salary,
		&i.PanNumber,
		&i.Year,
		&i.TaxIncome,
		&i.Deductions,
		&i.Designation,
	)
	return i, err
}

const updateEmployee = `-- name: UpdateEmployee :exec
UPDATE employee
SET
    name = $1,
    salary = $2,
    joining_date = $3,
    pan_number = $4,
    year = $5,
    tax_income = $6,
    deductions = $7,
    designation = $8,
    updated_at = NOW() -- Assuming you have an updated_at column and want to set it to the current time
WHERE employee_id = $9
`

type UpdateEmployeeParams struct {
	Name        string
	Salary      string
	JoiningDate time.Time
	PanNumber   string
	Year        int32
	TaxIncome   string
	Deductions  sql.NullString
	Designation string
	EmployeeID  uuid.UUID
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) error {
	_, err := q.db.ExecContext(ctx, updateEmployee,
		arg.Name,
		arg.Salary,
		arg.JoiningDate,
		arg.PanNumber,
		arg.Year,
		arg.TaxIncome,
		arg.Deductions,
		arg.Designation,
		arg.EmployeeID,
	)
	return err
}
